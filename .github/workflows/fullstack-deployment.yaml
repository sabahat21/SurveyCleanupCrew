name: Full Stack Deployment

#on:
 # push:
   # branches: 404-Not-Found-Deployment-Testing

jobs:
  setup-and-deploy:
    runs-on: ubuntu-latest

    env:
      AWS_REGION: us-east-1

    steps:
      - name: Checkout repo
        uses: actions/checkout@v3

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Backend: EC2 + Docker
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v2

      - name: Terraform Init
        run: terraform init
        working-directory: terraform/backend-ec2

      - name: Terraform Destroy (reset everything)
        run: terraform destroy -auto-approve
        working-directory: terraform/backend-ec2

      - name: Terraform Apply
        run: terraform apply -auto-approve
        working-directory: terraform/backend-ec2

      - name: Debug - list files
        run: ls -la terraform/backend-ec2
        
      - name: Extract EC2 Public IP from AWS
        id: ec2_output
        shell: bash
        run: |
          # Get the instance ID by tag Name=NodeBackendEC2 and state=running
          INSTANCE_ID=$(aws ec2 describe-instances \
            --filters "Name=tag:Name,Values=NodeBackendEC2" "Name=instance-state-name,Values=running" \
            --query "Reservations[0].Instances[0].InstanceId" \
            --output text)

          echo "üÜî INSTANCE_ID=$INSTANCE_ID"
      
          # Retry logic to get public IP
          for attempt in {1..5}; do
            EC2_PUBLIC_IP=$(aws ec2 describe-instances \
              --instance-ids "$INSTANCE_ID" \
              --query "Reservations[0].Instances[0].PublicIpAddress" \
              --output text)
      
            if [[ "$EC2_PUBLIC_IP" != "None" && -n "$EC2_PUBLIC_IP" ]]; then
              echo "‚úÖ Public IP acquired: $EC2_PUBLIC_IP"
              break
            fi
      
            echo "‚è≥ Attempt $attempt: Public IP not yet available. Retrying in 10 seconds..."
            sleep 10
          done
      
          # Final check
          if [[ "$EC2_PUBLIC_IP" == "None" || -z "$EC2_PUBLIC_IP" ]]; then
            echo "‚ùå Failed to retrieve EC2 Public IP after multiple attempts."
            exit 1
          fi
      
          # Export to GitHub environment variable
          echo "üåê EC2_PUBLIC_IP=$EC2_PUBLIC_IP"
          echo "EC2_PUBLIC_IP=$EC2_PUBLIC_IP" >> $GITHUB_ENV

      - name: Get EC2 DNS
        id: ec2_dns
        run: |
          EC2_PUBLIC_DNS="ec2-${EC2_PUBLIC_IP//./-}.compute-1.amazonaws.com"
          echo "EC2_PUBLIC_DNS=$EC2_PUBLIC_DNS" >> $GITHUB_ENV
        shell: bash

      - name: Write EC2 private key to file
        run: |
          echo "${{ secrets.EC2_SSH_PRIVATE_KEY }}" > backend-keypair.pem
          chmod 600 backend-keypair.pem

      - name: Install Docker on EC2
        run: |
          ssh -o StrictHostKeyChecking=no -i backend-keypair.pem ec2-user@$EC2_PUBLIC_DNS << 'EOF'
            sudo dnf install docker -y
            sudo systemctl enable docker
            sudo systemctl start docker
            sudo usermod -aG docker ec2-user
          EOF
        shell: bash
      
      - name: Copy backend and .env to EC2
        run: |
          scp -o StrictHostKeyChecking=no -i backend-keypair.pem -r backend ec2-user@$EC2_PUBLIC_DNS:/home/ec2-user/
          scp -o StrictHostKeyChecking=no -i backend-keypair.pem backend/.env ec2-user@$EC2_PUBLIC_DNS:/home/ec2-user/backend/.env
      
      - name: Build and run backend Docker container on EC2
        run: |
          ssh -o StrictHostKeyChecking=no -i backend-keypair.pem ec2-user@$EC2_PUBLIC_DNS << 'EOF'
            cd /home/ec2-user/backend
            docker build -t backend-app .
            docker run -d -p 8000:8000 --env-file .env backend-app
          EOF

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# API Gateway
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

      - name: Terraform Init (API Gateway)
        run: terraform init
        working-directory: terraform/api-gateway

      - name: Terraform Destroy (API Gateway)
        run: terraform destroy -auto-approve -var="ec2_public_ip=$EC2_PUBLIC_IP"
        working-directory: terraform/api-gateway

      - name: Terraform Apply (API Gateway)
        run: terraform apply -auto-approve -var="ec2_public_ip=$EC2_PUBLIC_IP"
        working-directory: terraform/api-gateway

      - name: Get API Gateway URL directly from AWS
        id: api_output
        run: |
          API_ID=$(aws apigatewayv2 get-apis \
            --query "Items[?contains(Name, 'ec2-backend-api')].ApiId" \
            --output text)
      
          if [ -z "$API_ID" ]; then
            echo "‚ùå Failed to retrieve API ID"
            exit 1
          fi
      
          API_GATEWAY_URL="https://${API_ID}.execute-api.us-east-1.amazonaws.com"
      
          echo "üåê API Gateway URL: $API_GATEWAY_URL"
          echo "API_GATEWAY_URL=$API_GATEWAY_URL" >> $GITHUB_ENV

          
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Frontend: React + S3 + CloudFront
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

      - name: Terraform Init
        run: terraform init
        working-directory: terraform/frontend-s3

      - name: Empty S3 bucket before destroy (only if exists)
        run: |
          BUCKET_NAME="my-sanskrit-survey-frontend-bucket"
          
          # Check if the bucket exists
          if aws s3api head-bucket --bucket "$BUCKET_NAME" 2>/dev/null; then
            echo "‚úÖ Bucket exists. Proceeding to empty it..."
            aws s3 rm s3://$BUCKET_NAME --recursive
          else
            echo "‚ö†Ô∏è Bucket $BUCKET_NAME does not exist. Skipping empty step."
          fi

      - name: Terraform Destroy
        run: terraform destroy -auto-approve
        working-directory: terraform/frontend-s3

      - name: Terraform Apply
        run: terraform apply -auto-approve
        working-directory: terraform/frontend-s3
    
      - name: Create .env file and build React App
        working-directory: ./frontend
        run: |
          echo "REACT_APP_MONGO_API=$API_GATEWAY_URL" > .env
          echo "REACT_APP_API_KEY=H0ylHQmpyATxhhRUV3iMEfQnq1xkZl0uUGN9g26OubSw6Od5H0XwKGCMJhaY7TwL" >> .env

          echo "‚úÖ .env file created:"
          cat .env

          npm ci
          npm run build

      - name: Extract S3 and CloudFront Info from AWS
        id: aws_outputs
        shell: bash
        run: |
          # Find S3 bucket name by prefix (adjust the filter if needed)
          S3_BUCKET_NAME=$(aws s3api list-buckets --query "Buckets[?starts_with(Name, 'my-sanskrit-survey-frontend')].Name" --output text)

          # Find CloudFront distribution ID by comment or origin (adjust filter if needed)
          DISTRIBUTION_ID=$(aws cloudfront list-distributions \
            --query "DistributionList.Items[?Origins.Items[0].DomainName.contains(@, '$S3_BUCKET_NAME')].Id" \
            --output text)

          echo "‚úÖ S3_BUCKET_NAME=$S3_BUCKET_NAME"
          echo "‚úÖ DISTRIBUTION_ID=$DISTRIBUTION_ID"

          echo "S3_BUCKET_NAME=$S3_BUCKET_NAME" >> $GITHUB_ENV
          echo "DISTRIBUTION_ID=$DISTRIBUTION_ID" >> $GITHUB_ENV


      - name: Confirm extracted env vars
        run: |
          echo "üåê Confirmed:"
          echo "S3_BUCKET_NAME: $S3_BUCKET_NAME"
          echo "DISTRIBUTION_ID: $DISTRIBUTION_ID"
        env:
          S3_BUCKET_NAME: ${{ env.S3_BUCKET_NAME }}
          DISTRIBUTION_ID: ${{ env.DISTRIBUTION_ID }}


        
      - name: Install dependencies and build React app
        working-directory: ./frontend
        run: |
          npm ci
          npm run build

      - name: Upload build/ to S3
        run: |
          aws s3 sync ./frontend/build s3://$S3_BUCKET_NAME --delete

      - name: Invalidate CloudFront cache (optional but recommended)
        if: env.DISTRIBUTION_ID != ''
        run: |
          aws cloudfront create-invalidation \
            --distribution-id ${{ env.DISTRIBUTION_ID }} \
            --paths "/*"
